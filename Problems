********** 1. Two Sum **********

Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.
You may assume that each input would have exactly one solution, and you may not use the same element twice.
You can return the answer in any order.

Example 1:

Input: nums = [2,7,11,15], target = 9
Output: [0,1]
Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].

Example 2:

Input: nums = [3,2,4], target = 6
Output: [1,2]

Example 3:

Input: nums = [3,3], target = 6
Output: [0,1]

Source Code ->

class Solution {
    public int[] twoSum(int[] nums, int target) {
  
        for(int i =0; i<nums.length ; i++){
            for(int j = i +1 ; j <nums.length; j++){
                if(nums[j] == target - nums[i]){
                    return new int[] {i,j};
                }
            }
        }
        
        return null;
        
    }
}


2. Add Two Numbers

You are given two non-empty linked lists representing two non-negative integers. 
The digits are stored in reverse order, and each of their nodes contains a single digit. 
Add the two numbers and return the sum as a linked list.

You may assume the two numbers do not contain any leading zero, except the number 0 itself.

Example 1:

Input: l1 = [2,4,3], l2 = [5,6,4]
Output: [7,0,8]
Explanation: 342 + 465 = 807.

Example 2:

Input: l1 = [0], l2 = [0]
Output: [0]

Example 3:

Input: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
Output: [8,9,9,9,0,0,0,1]
 

Constraints:

The number of nodes in each linked list is in the range [1, 100].
0 <= Node.val <= 9
It is guaranteed that the list represents a number that does not have leading zeros.


4. Median of Two Sorted Arrays

Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.

The overall run time complexity should be O(log (m+n)).

 

Example 1:

Input: nums1 = [1,3], nums2 = [2]
Output: 2.00000
Explanation: merged array = [1,2,3] and median is 2.
Example 2:

Input: nums1 = [1,2], nums2 = [3,4]
Output: 2.50000
Explanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.
 

Constraints:

nums1.length == m
nums2.length == n
0 <= m <= 1000
0 <= n <= 1000
1 <= m + n <= 2000
-106 <= nums1[i], nums2[i] <= 106

class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int i = 0, j = 0, z = 0;
        int n = nums1.length ,m = nums2.length;

        int a=n+m;
        int ans[]=new int[a];

        while(i<n && j<m){
        if(nums1[i]<nums2[j]){
        ans[z++]=nums1[i++];
        }else{
        ans[z++]=nums2[j++];
        }
        } 
        while(i<n){
        ans[z++]=nums1[i++];
        }
        while(j<m){
        ans[z++]=nums2[j++];
        }
        if(a%2!=0)
        return ans[(a/2)];
        else
        return (ans[(a/2)-1]+ans[(a/2)])/2.0;
        }
        }   

5. Longest Palindromic Substring

Given a string s, return the longest palindromic substring in s.

 

Example 1:

Input: s = "babad"
Output: "bab"
Explanation: "aba" is also a valid answer.
Example 2:

Input: s = "cbbd"
Output: "bb"
 

Constraints:

1 <= s.length <= 1000
s consist of only digits and English letters.

Source Code->

class Solution {
    public String longestPalindrome(String s) {
        
        if(s.length() == 1){
            return s;
        }
        
        int maxLength =0;
        int start =0;
        
        for(int i =0; i< s.length(); i++){
            int curLength =  Math.max(getLength(s,i,i) , getLength(s,i,i+1));
            if(curLength > maxLength){
                maxLength = curLength;
                start = i - (curLength -1)/2;
            }
        }
        
        return s.substring(start,start +maxLength);
    }
    
        private static int getLength(String s, int l, int r){
            while(l >= 0 && r < s.length() && s.charAt(l) == s.charAt(r)){
                l--;
                r++;
            }
            return r-l-1;
        }
    }
    
    
7. Reverse Integer

Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0.

Assume the environment does not allow you to store 64-bit integers (signed or unsigned).

 

Example 1:

Input: x = 123
Output: 321
Example 2:

Input: x = -123
Output: -321
Example 3:

Input: x = 120
Output: 21
 

Constraints:

-231 <= x <= 231 - 1

class Solution {
    public int reverse(int x) {
        
        int reverse =0;                                                            // Intialise reverse
        
        int modulo;                                                                // Intialise modulo                        
        
        while(x != 0){
            modulo = x%10;
            x /= 10;
            
            
            if(reverse > Integer.MAX_VALUE/10 || reverse == Integer.MAX_VALUE/10 && modulo > 7) return 0;
            
            /* Integer. MAX_VALUE represents the maximum positive integer value that can be represented in 32 bits (i.e., 2147483647 ). This means that no number of type Integer that is greater than 2147483647 can exist in Java. */
            
            if(reverse < Integer.MIN_VALUE/10 || reverse == Integer.MIN_VALUE/10 && modulo <-8) return 0;
            
            /* Integer.MIN_VALUE is a constant in the Integer class of java.lang package that specifies that stores the minimum possible value for any integer variable in Java. The actual value of this is -2^31 = -2147483648 */

            reverse = (reverse *10) + modulo;
        }
        
            return reverse;
    }
}


/*  if reversedNumber is exactly equal to Integer.MAX_VALUE / 10 then we need to check the + lastDigit we add should be less that 7 (for positive number) because in Java, the integer ranges from -2,147,483,648 to +2,147,483,647 and greater than -8 in case negative number.*/

9. Palindrome Number

Given an integer x, return true if x is palindrome integer.

An integer is a palindrome when it reads the same backward as forward.

For example, 121 is a palindrome while 123 is not.
 

Example 1:

Input: x = 121
Output: true
Explanation: 121 reads as 121 from left to right and from right to left.
Example 2:

Input: x = -121
Output: false
Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.
Example 3:

Input: x = 10
Output: false
Explanation: Reads 01 from right to left. Therefore it is not a palindrome.
 

Constraints:

-231 <= x <= 231 - 1

class Solution {
    public boolean isPalindrome(int x) {
        
        if(x == 0){
            return true;
        }
        
        if(x < 0 || x%10 == 0){
            return false;
        }
        
        int reversed_int = 0;
        while(x > reversed_int){
            int modulo = x%10;
            x /= 10;
            
            reversed_int = (reversed_int *10) + modulo;
            
        }
        
        if(x == reversed_int || x == reversed_int / 10){
            return true;
        }
        else{
            return false;
        }
    }
}

11. Container With Most Water

You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).

Find two lines that together with the x-axis form a container, such that the container contains the most water.

Return the maximum amount of water a container can store.

Notice that you may not slant the container.

 

Example 1:


Input: height = [1,8,6,2,5,4,8,3,7]
Output: 49
Explanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.
Example 2:

Input: height = [1,1]
Output: 1
 

Constraints:

n == height.length
2 <= n <= 105
0 <= height[i] <= 104
class Solution {
    public int maxArea(int[] height) {
        /*
        int max = Integer.MIN_VALUE;
        for(int i =0; i< height.length; i++){
            for(int j=i; j<height.length; j++){
                int min = Math.min(height[i], height[j]);
                max= Math.max(max, min*(j-i));
            }
        }
                              
        return max;
        
        */
        
        
        int maxWater = Integer.MIN_VALUE;
        int i =0;
        int j =height.length -1;
        
        while(i < j){
            int min = Math.min(height[i], height[j]);
            maxWater = Math.max(maxWater, min*(j-i));
            if(height[i] < height[j]){
                i++;
                
            }else{
                j--;
            }
                          
                          
        }
        return maxWater;
    }
}

    
12. Integer to Roman

Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.

Symbol       Value
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
For example, 2 is written as II in Roman numeral, just two one's added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.

Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:

I can be placed before V (5) and X (10) to make 4 and 9. 
X can be placed before L (50) and C (100) to make 40 and 90. 
C can be placed before D (500) and M (1000) to make 400 and 900.
Given an integer, convert it to a roman numeral.

 

Example 1:

Input: num = 3
Output: "III"
Explanation: 3 is represented as 3 ones.
Example 2:

Input: num = 58
Output: "LVIII"
Explanation: L = 50, V = 5, III = 3.
Example 3:

Input: num = 1994
Output: "MCMXCIV"
Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.
 

Constraints:

1 <= num <= 3999

Source Code -> 

Method 1.

class Solution {
    public String intToRoman(int num) {
        
        int[] values ={1,4,5,9,10,40,50,90,100,400,500,900,1000};
        String[] roman ={"I","IV","V","IX", "X", "XL", "L", "XC", "C", "CD", "D" , "CM", "M"};
        
        StringBuilder sb = new StringBuilder();
        
        for(int i = values.length-1; i>=0 && num >0; i--  ){
            while(num >= values[i]){
                num -= values[i];
                sb.append(roman[i]);
            }
        }
        return sb.toString();
    }
}


Method 2.

class Solution { 
    private static final String[] thousands = {"", "M", "MM", "MMM"};
    private static final String[] hundreds = {"", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM"}; 
    private static final String[] tens = {"", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC"};
    private static final String[] ones = {"", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"};
    
    public String intToRoman(int num) { 
        return thousands[num / 1000] + hundreds[num % 1000 / 100] + tens[num % 100 / 10] + ones[num % 10];
    }
}

13. Roman to Integer

Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.

Symbol       Value
I             1
V             5
X             10
L             50
C             100
D             500
M             1000
For example, 2 is written as II in Roman numeral, just two one's added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.

Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:

I can be placed before V (5) and X (10) to make 4 and 9. 
X can be placed before L (50) and C (100) to make 40 and 90. 
C can be placed before D (500) and M (1000) to make 400 and 900.
Given a roman numeral, convert it to an integer.

 

Example 1:

Input: s = "III"
Output: 3
Explanation: III = 3.
Example 2:

Input: s = "LVIII"
Output: 58
Explanation: L = 50, V= 5, III = 3.
Example 3:

Input: s = "MCMXCIV"
Output: 1994
Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.
 

Constraints:

1 <= s.length <= 15
s contains only the characters ('I', 'V', 'X', 'L', 'C', 'D', 'M').
It is guaranteed that s is a valid roman numeral in the range [1, 3999].

class Solution {
    public int romanToInt(String s) {
        
        
    HashMap<Character, Integer> map = new HashMap<>();
        
        map.put('I', 1);
        map.put('V', 5);
        map.put('X', 10);
        map.put('L', 50);
        map.put('C', 100);
        map.put('D', 500);
        map.put('M', 1000);
        
        
        // 'IV' -> 1 -1 + 5 -> wrong   So, 'IV' -> 1 -2 + 5 -> 4 Right 
        
        int sum =0;
        
        for(int i =0; i< s.length(); i++){
            if(s.charAt(i) == 'V' || s.charAt(i) == 'X'){
                if(i > 0 && s.charAt(i-1) == 'I')
                    sum -= 2;
            }
            if(s.charAt(i) == 'L' || s.charAt(i) == 'C'){
                if(i > 0 && s.charAt(i-1) == 'X')
                    sum -= 20;
            }
            if(s.charAt(i) == 'D' || s.charAt(i) == 'M'){
                if(i > 0 && s.charAt(i-1) == 'C')
                    sum -= 200;
            }
            
            sum += map.get(s.charAt(i));
        }
         return sum;
        
        
        
    }
}


14. Longest Common Prefix

Write a function to find the longest common prefix string amongst an array of strings.

If there is no common prefix, return an empty string "".

 

Example 1:

Input: strs = ["flower","flow","flight"]
Output: "fl"
Example 2:

Input: strs = ["dog","racecar","car"]
Output: ""
Explanation: There is no common prefix among the input strings.
 

Constraints:

1 <= strs.length <= 200
0 <= strs[i].length <= 200
strs[i] consists of only lower-case English letters.

class Solution {
    public String longestCommonPrefix(String[] strs) {
        
        if(strs.length == 0 || strs == null)
            return "";
        
        
        for(int i =0; i< strs[0].length(); i++){
            char c = strs[0].charAt(i);
            
            for(int j = 1 ; j< strs.length; j++){
                if(i == strs[j].length() || strs[j].charAt(i) != c)
                    return strs[0].substring(0,i);
            }
        }
        return strs[0];    
    }           
}
